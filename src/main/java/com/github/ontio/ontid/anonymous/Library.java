package com.github.ontio.ontid.anonymous;

import com.sun.jna.Native;
import com.sun.jna.Pointer;

public interface Library extends com.sun.jna.Library {
    Library INSTANCE = Native.loadLibrary("lib/liboacp.dylib", Library.class);

    /**
     * Create a new issuer.
     * The returned pointer should be freed via `free_issuer`.
     * <p>
     * 新建一个证书颁发者。
     * 返回的指针需使用free_issuer释放。
     */
    Pointer new_issuer();

    /**
     * 序列化issuer
     *
     * @param issuer
     * @return
     */
    String serialize_issuer(Pointer issuer) throws Exception;

    /**
     * 反序列化issuer
     *
     * @param issuer_str
     * @return
     */
    Pointer deserialize_issuer(String issuer_str) throws Exception;

    /**
     * Free the memory of a issuer object.
     * <p>
     * 释放证书颁发者对象。
     */
    void free_issuer(Pointer issuer) throws Exception;

    /**
     * Save the issuer's public data to the buffer `pub`.
     * The caller must ensure that the buffer size is ISSUER_PUBLIC_SIZE.
     * <p>
     * 降颁发者`issuer`的公钥数据写入`pub`指向的数组中。
     * 数组的尺寸必须为ISSUER_PUBLIC_SIZE。
     */
    void publish_issuer(byte[] pub, Pointer issuer) throws Exception;

    /**
     * Save the issuer's accumulator value to the buffer `value`.
     * The buffer size should be ACC_VALUE_SIZE.
     * <p>
     * 降颁发者`issuer`维护的累加器的值写入`buffer`指向的数组中。
     * 数组的尺寸必须为ACC_VALUE_SIZE。
     */
    void get_accumulator_value(byte[] value, Pointer issuer) throws Exception;

    /**
     * Get the public information of the issuer's accumulator.
     * The returned information is formatted as json, and should
     * be freed by `free_str`.
     * <p>
     * 获取颁发者的累加器的公钥。
     * 返回值为一个json字符串，需由free_str释放。
     */
    String get_accumulator_info(Pointer issuer) throws Exception;

    /**
     * Free the memory of an allocated string.
     * <p>
     * 释放本模块分配的字符串数组的内存。
     */
    void free_str(String s);

    /**
     * Generate a new master secret of the user.
     * The buffer should be the size of 32.
     * <p>
     * 生成一个用户的主私钥，并写入`master_secret`中。
     * 数组尺寸须为32字节。
     */
    void new_master_secret(byte[] master_secret) throws Exception;

    /**
     * Make a issue request with the master secret and attributes.
     * 创建一个证书颁发请求，包括用户的主私钥及要包含在证书中的属性。
     * <p>
     * `attributes` is a json string.
     * `attributes` 是一个json字符串。
     * <p>
     * `nonce` is a 16 bytes random value, which should be received from the issuer.
     * `nonce` 是一个16字节的随机挑战，应由颁发者生成并发送给用户。
     * <p>
     * The returned value is a json string, which should be freed via `free_str`.
     * 返回值是一个json字符串，需由free_str释放。
     * <p>
     * An example of attributes
     * 以下是一个用户属性的例子
     * <p>
     * {
     * "name": "Alice",
     * "age": 22,
     * "sex": "female"
     * }
     */
    String make_issue_request(byte[] master_secret, String attributes, byte[] nonce, byte[] issuer_public) throws Exception;

    /**
     * Issue a credential according to the request, which is generated by
     * `make_issue_request`.
     * 颁发者`issuer`根据请求`request`颁发一张证书。
     * <p>
     * The returned value is json string, which should be freed via `free_str`.
     * 返回值是一个json字符串，需由free_str释放。
     */
    String issue_credential(Pointer issuer, String request) throws Exception;

    /**
     * Revoke the credential with the id `i` issued by `issuer`.
     * 颁发者`issuer`撤销其颁发的ID为`i`的证书。
     * <p>
     * Return 0 if succeeds, otherwise -1.
     * 若撤销成功，返回0；否则返回-1。
     */
    int revoke_credential(Pointer issuer, Long i) throws Exception;

    /**
     * Extract the witness from the issued credential.
     * 从颁发的证书数据中抽取出累加器witness数据。
     * <p>
     * The caller must ensure the output buffer `witness` has the
     * size of ACC_WITNESS_SIZE.
     * 数组`witness`需由调用者创建，尺寸为ACC_WITNESS_SIZE。
     * <p>
     * Return 0 if succeeds, otherwise -1.
     * 抽取成功返回0，否则返回-1。
     */
    int extract_witness(byte[] witness, String credential) throws Exception;

    /**
     * Update a witness after the accumulator is updated (new credential is
     * issued or old credential is revoked).
     * This should be called by the issuer, who manages the witnesses.
     * 当累加器的值更新后（颁发了新的证书或撤销了一张证书），同步更新历史证书的witness。
     * 此接口应由颁发者调用，因为其负责维护历史证书的witness。
     * <p>
     * `witness` should be the one extracted via `extract_witness`.
     * `witness` 应为接口extract_witness返回的数据。
     * <p>
     * `is_add` should be 1, if a credential with id `i` is issued;
     * or 0, if the credential with id `i` is revoked.
     * 若是颁发了ID为`i`的证书，则`is_add`值为1；
     * 若是撤销了ID为`i`的证书，则`is_add`值为0。
     */
    int update_witness(byte[] witness, byte[] new_witness, Pointer issuer, Long i, byte is_add) throws Exception;

    /**
     * Update the accumulator witness in a credential, after the accumulator is
     * updated (new credential issued or old credential revoked).
     * 当累加器更新后（颁发了新证书或撤销了旧证书），更新证书中的累加器witness。
     * <p>
     * `credential` is the credential data, which should be a json string.
     * `credential`是证书数据，是一个json字符串。
     * <p>
     * `witness` is the latest witness received from the issuer, whose size should
     * be ACC_WITNESS_SIZE.
     * `witness`是从颁发者获取的最新的witness值，应是一个长为ACC_WITNESS_SIZE的字节数组。
     * <p>
     * `accumulator` is the latest accumulator value, whose size should be
     * ACC_VALUE_SIZE.
     * `accumulator`是最新的累加器的值，应是一个长为ACC_VALUE_SIZE的字节数组。
     * <p>
     * Return 0 if succeeds, otherwise -1.
     * 若更新成功，返回0；否则返回-1。
     */
    String update_credential_witness(String credential, byte[] issuer_public, byte[] witness, byte[] accumulator) throws Exception;

    /**
     * Present a credential.
     * 出示证书。
     * <p>
     * `credential` is the credential data, should be a json string.
     * `credential`是证书数据，是一个json字符串。
     * <p>
     * The attributes can be either a value, a range or just hidden.
     * The argument `attributes` is a json string.
     * 出示的证书中属性的值可以明确展示，或仅给出一个取值范围，或者隐藏。
     * <p>
     * Following is an example
     * 以下是一个属性展示的例子
     * {
     * "name": {"value": "Alice", "state": "disclose"},
     * "age": {"value": 22, "state": "range", "range": [18, 100]},
     * "sex": {"value": "female", "state": "hide"}
     * }
     * <p>
     * `accumulator` is the issuer's latest accumulator value.
     * `accumulator`是颁发者的累加器的最新值。
     * <p>
     * `nonce` is a 128 bits random value generated by the verifier.
     * `nonce`是由验证者给出的一个128比特的随机挑战。
     * <p>
     * The returned value is a json string, which should be freed via `free_str`.
     * 返回值是一个json字符串，需由free_str释放。
     */
    String present(String credential, byte[] master_secret, String attributes, byte[] issuer_public, byte[] accumulator, byte[] nonce) throws Exception;

    /**
     * Verify a presentation.
     * 验证一个出示的证书是否合法。
     * <p>
     * `presentation` is the json string returned by `present`.
     * `presentation`是present接口返回的证书出示数据。
     * <p>
     * `accumulator` is the accumulator value, should be the same one when
     * user calling `present` (usually the latest).
     * `accumulator`是证书颁发者的累加器的值，需与present接口使用的为同一个值
     * （通常使用最新值即可）。
     * <p>
     * `nonce` is the same value passed to `present`.
     * `nonce`是随机挑战，同present接口使用的为同一个值。
     * <p>
     * Return 0 if verification passed, otherwise -1.
     * 若验证成功，返回0；否则返回-1。
     */
    int verify(String presentation, byte[] issuer_public, byte[] accumulator, byte[] nonce) throws Exception;
}
